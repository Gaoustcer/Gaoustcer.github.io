---
layout:     post
title:      计算机体系结构期末复习——动态指令流调度
subtitle:   计算机体系结构期末复习——动态指令流调度
date:       2021-06-27
author:     Haihan Gao
header-img: img/post-bg-swift2.jpg
catalog: true
tags:
    - Computer Architecture
    - Course review
    - 2021 spring review
---
# 计算机体系结构期末复习——动态指令流调度

## 指令集并行的基本思想

### 硬件调度方案

* 编译时无法确定的相关，可以通过硬件调度优化
* 编译器优化
* 二进制兼容

### 基本思想

允许stall后的指令继续向前流动，允许乱序执行——数据流驱动

## 记分牌方案

### 基本概念

* 取指令，将指令放入指令窗口
* 译码，检测数据相关issue
  * 互锁机制解决相关(等待)
* 读操作数
* 执行(ALU，访存)
* 写回

### 解决和检测数据相关的方法

有多个功能部件或执行部件流水话，需要有多条指令进入执行阶段

#### WAR

* 对操作排队
* 仅仅在读操作数(RO)阶段读寄存器

#### WAW

* 检测到相关后，停止发射前一条指令，直到前一条指令完成

### ISSUE阶段

* 判断使用的是什么功能部件，结构异常
* 判断是否存在WAW相关
* 存在WAW或者结构相关，停止发射

### RO阶段——检测是否存在真正的数据相关RAW

* 解决RAW相关
* 操作数有效时，进入执行，否则等待

### EX

执行，执行结束修改记分牌，开始暂停的指令执行

### WR

* 记分牌得到功能部件执行完毕的信息后，记分牌检测WAR相关
* 没有WAR相关，写结果——操作数已经读走了
* 存在WAR相关，暂停写回——操作数还没被读走

### 记分牌的结构

#### Instruction Status

指令执行到哪个阶段

#### Function unit status

* Busy是否空闲
* Op部件完成的操作
* 目的寄存器**编号**$F_i$
* 源寄存器**编号**$F_j,F_k$
* 产生源操作数的**功能部件**$Q_i,Q_k$
* 源操作数**是否就绪**的标志$R_j,R_k$

#### Register result status

存在功能部件写某个寄存器，则在寄存器结果状态表中记录该功能部件，没有写操作记作`blank`

### 记分牌控制

#### ISSUE阶段

##### 进入条件(WAW解决)

功能部件不忙，目的寄存器不被写

##### 进入issue段的操作

* 功能部件修改为忙
* $F_i(FU)=D,F_j(FU)=S_1,F_k(FU)=S_2$
* $Q_j=Result(S_1),Q_k=Result(S_2)$查找寄存器结果状态表，$Q_j,Q_k$是写源寄存器的功能部件
* $R_j=\not {Q_j},R_k=\not {Q_k}$，即如果没有功能部件操作源寄存器，R将会是1

#### RO

准入条件为 $R_j\&R_k$,需要修改$R_j,R_k$为No

#### WB

##### 准入条件(RAW解决)

对于两个操作数$F_j,F_k$，需要满足如下条件才能进入WB阶段

1. $\forall f(f是功能部件)(F_j(f)\neq F_i(FU)\or R_j(f)=No)$
   1. $F_j(f)\neq F_i(FU)$表明写回指令的目的寄存器和在缓冲区中指令的源寄存器不是同一个
   2. $R_j(f)=No$表明源寄存器已经被读走
2. $\forall f(f是功能部件)(F_k(f)\neq F_i(FU)\or R_k(f)=No)$
   1. $F_k(f)\neq F_i(FU)$表明写回指令的目的寄存器和在缓冲区中指令的源寄存器不是同一个
   2. $R_k(f)=No$表明源寄存器已经被读走

##### 操作——修改寄存器状态为有效，可以读

1. $\forall f(if\ Q_j(f)=FU \ then \ R_j(f)=Yes)$
2. $\forall f(if\ Q_k(f)=FU \ then \ R_k(f)=Yes)$
3. $Result(F_i(FU))=0,Busy(FU)=No$

### 总结——记分牌方案

* 顺序发射，乱序完成
* 发射前检测结构相关和WAW相关
* 读操作数前检测RAW相关(之前发射的指令必须要写寄存器，两个操作数需要准备好)
* 写结果前处理WAR相关(没读走不能写回)

### 缺陷

* 没有定向路径
* 指令窗口受限于功能部件数目
* WAR WAW相关是假相关，可以通过寄存器重命名解决，但是这里采用了等待的方式

## Tomasulo算法

### 基本思想

* 控制和缓存分布在各个功能部件中——保留站
* 记录原操作寄存器的值而不是编号——寄存器重命名，解决WAR，WAW冒险
* 可以跨越分支——Reorder buffer和分支预测
* FU的结果来自保留站而不是寄存器

### 基本架构

* 每个功能部件有一个reservation station
* 每个保留站含有多个line，每个line可以暂存一条指令
* CDB总线将写回结果广播到各个功能部件和保存站中
* 访存指令放入一个queue中，分为load queue和store queue

### 保留站的结构

* $V_j,V_k$源操作数的**值**
* A存储器地址，开始存放立即数，后面被替换为永久地址
* $Q_j,Q_k$产生源操作数的保留站
  * 如果$Q_j=Q_k=0$，则代表数据准备就绪
  * store buffer中$Q_k$表示产生结果的保留站
* Busy是否空闲
* 寄存器保留站
  * $Q_i$写寄存器的保留站编号

### 执行流程

* ISSUE 从FP操作队列中取指令
* EX两操作数就绪后，可以执行
* WB，CDB广播
  * CDB总线采取的是data+source方案
  * 标记功能部件源地址
  * 与RS中等待的部件匹配，执行写操作

### 流水线控制

#### ISSUE

##### 准入条件

保留站空闲

##### 动作

* FP操作
  * $if(RegisterStat[rs/rt].Q_i\neq 0)RS[r].Q_j=RegisterStat[rs/rt].Q_i$ 源寄存器是否被存留在保留站中的某条指令写
  * $else\ RS[r].V_j/V_k=Reg[rs/rt],RS[r].Q_j/Q_k=0$ 如果没被写，则直接从寄存器堆中读取数据，并将数据有效位置为有效
  * $RS[r].Busy=Yes RegisterStat[rd].Q_i=r$
* Load Store操作
  * $if(RegisterStat[rs].Q_i\neq 0)RS[r].Q_j=RegisterStat[rs].Q_i$
  * $else\ RS[r].V_j=Reg[rs/rt],RS[r].Q_j=0$同理，查看基址寄存器是否准备好，准备好直接从寄存器堆读
  * $RS[r].A=imm,RS[r].Busy=yes$
    * load
      * $RegisterStat[rt].Qi=r$->存储器到寄存器
    * store
      * $if(RegisterStat[rt].Qi\neq0)\ RS[r].Q_k=RegisterStat[rt].Q_i$
      * $else\ RS[r].V_k=Reg[rt],RS[r].Q_k=0$写入存储器的寄存器是否准备好

#### EX

* FP运算 $RS[r].Q_j=0 \ and \ RS[r].Q_k=0 $
* Load store操作$RS[r].Q_j=0\ and \ $is the head of load-store queue**访存操作必须顺序执行**
  * load store不乱序
  * 第一阶段，等待基址寄存器有效 wait until $RS[r].Q_j=0$，接着计算有效地址$RS[r].A=rS[r].V_j+RS[r].A$
  * 第二阶段，读/写存储器

#### WB

##### 准入条件

* FP操作，需要等待直到执行完毕并且CDB总线空闲
* store，需要等待直到写入存储器的寄存器准备好$RS[r].Q_k=0$

##### 操作

###### FP部件

* 对于寄存器堆保留站，需要写回寄存器堆数据，并修改$RegisterStat[x].Q_i=0$
* 对于其它功能部件保留站，如果$RS[x].Q_j=r,then\ RS[x].V_j=result,RS[x].Q_j=0$，实现数据旁路
* 功能部件Busy置为No

###### Store

写入数据，修改功能部件Busy位

### 算法特点

* 分布式控制
* 使用寄存器重命名解决WAW，WAR相关

### Tomasulo算法实现硬件循环展开

#### 基本思想

* 分支预测，引入不同iteration的循环指令——预测跳转
* 寄存器重命名，保证不同iteration的相同指令，可以并行执行
* 循环展开的次数取决于保留站大小

#### 访存冒险检测

* 避免访存指令一定按照程序序执行的弱点
* 访存之前检查访存地址是否和缓冲区中程序序在这条指令之前的访存地址一致

## 分支预测

### Correlating Branches

* 基本思想：每个分支指令存在两个分支预测器，根据上一条指令是否跳转选择特定的分支预测器执行跳转操作
* 可以根据更久远的历史做出判断，比如2bit全局历史分支预测器
* 表示为(m,n)，根据最近的m个分支，从$2^m$个分支预测器中选择一个预测器，每个预测器的位数为$n$

### 关联预测器$(m,n)$

* 两级全局预测器
  * 根据**最近的n次分支的执行情况**从$2^n$个预测器中选择预测器
* 两级局部预测器
  * 根据**该分支的最近n次分支执行情况**从$2^n$个预测器中选择预测器
* 每个分支含有多个2-bit预测器

### 竞赛预测器

* 使用分支预测地址的低m位分支局部地址索引，每个索引得到一个两位计数器，决定选择局部预测器还是全局预测器
* 全局/局部预测器均预测错误，不改变计数器，全局正确但是局部错误计数器+1，全局错误但是局部正确计数器-1

### 基于BTB的预测

* 间接地址——运行时方可确定分支目标地址
* 间接跳转来自过程返回
* 使用小的缓存栈存放返回地址，发生过程调用将返回地址压栈，过程返回时弹栈

## 存储器访问冲突消解

### 四种策略

* Total ordering 所有访存指令严格按照程序序执行
* Partial Ordering store指令按照程序序执行，load指令需要在程序序在此之前的所有store指令执行完才能执行
* Load ordering Store ordering，load store分别有序
* store ordering store指令有序，load乱序

思考：为何不规定访存指令之外的指令与访存指令的数据相关？

回答：这些相关仅仅存在于寄存器与寄存器之间，`Tomasulo`算法使用重命名解决，记分牌使用等待解决