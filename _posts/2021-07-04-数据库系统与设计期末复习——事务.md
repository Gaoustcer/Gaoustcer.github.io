---
layout:     post
title:      数据库系统与应用期末复习——事务
subtitle:   数据库系统与应用期末复习——事务
date:       2021-07-04
author:     Haihan Gao
header-img: img/post-bg-swift2.jpg
catalog: true
tags:
    - Database
    - Course review
    - 2021 spring review
---
# 数据库系统与设计期末复习——事务

## 事务的状态以及原语操作

### 事务的性质

* 原子性——保证事务不可分，要么都做，要么都不做
* 一致性——事务保证数据库从一个状态转到另一个状态
* 隔离性——多个事务一起执行时相互独立
* 持久性——事务需要写回磁盘

### 事务在日志中的记录

* Start T 事务T已经开始
* Commit T 事务T正常终止并且修改已经固化到硬盘中
* Abort T 事务异常终止，所有对数据库的修改被撤销

### 事务原语操作

* Input(X) 从硬盘加载数据到内存
* Output(X) 将数据写回硬盘
* Read(X,t)读X并写道变量t中
* Write(X,t)将t写道内存的X中

### SQL&&事务

* Begin Transaction
* Commit Transaction
* Rollback Transaction

## 数据库的一致性与故障

### 一致性

事务完成前后必须满足数据库一致性，即满足某些约束，但是事务执行到一半可以不满足这些约束

### 一致状态

满足一致性约束的状态

### 数据库故障

#### 事务故障

发生在单个事务内部的故障

* 可预期——由应用程序处理
* 不可预期——由操作系统进行处理

#### 介质故障

磁盘损坏

#### 系统故障

软件问题或掉电

### 恢复策略

* 恢复到最近的一致状态
* 冗余原则
* 实现
  * 定期备份
  * 事务日志
  * 通过日志和备份进行恢复

## Redo日志与Undo日志

### 基本原则

先写日志——需要先把修改写到磁盘上随后写入修改后的数据

### Undo日志——立即更新

#### 内容

* 严格按照执行时间排序
* 具体内容
  * 事务的开始标记 `<Start T>`
  * 事物的结束标记(正常结束&&异常结束)`<Commit T> <Abort T>`
  * 事务的更新操作 `<T A old_value>`
    * T 事务表示
    * A 事务的操作对象
    * old_value更新前的A值

#### 规则

所有数据修改结果被写入到磁盘后，再写`<Commit T>`日志

#### 基于Undo日志的恢复

* 从头扫描日志，找出所有没有终止的事务，放入一个事务列表L中
* 从尾部开始扫描日志记录`<T,x,v>,if` $T\in L$
  * `write(X,v)`
  * `output(X)`
* for each $T\in L$ do
  * write `<Abort,T>` to log

### Redo日志——延迟更新

#### 规则

先写日志和数据，再写commit

#### 恢复

* 针对所有commit的事务操作即可
* 从首部开始扫描日志记录，如果$T\in L$
  * `write(X,v)`
  * `output(X)`
* for each $T\notin L$，没有commit则一定不会写磁盘
  * write `<Abort,T>` to log

### Undo && Redo日志

* 正向扫描日志，将commit的事务放入Redo列表中，将没有commit的事务放入Undo列表中
* 反向扫描日志，对于`<T,x,v,w>,if `$T\in Undo$
  * Write(x,v) Output(x)
* 正向扫描日志，对于`<T,x,v,m>,if `$T\in Redo$
  * Write(x,w) Output(x)
* 对于Undo列表中的T，写入`<abort,T>`

## 三大并发问题

### 丢失更新问题

* 事务T1读A
* 事务T2读A
* 事务T1修改A
* 事务T2修改A
* 事务T1写回修改结果
* 事务T2写回修改结果

### 脏读——仅出现Rollback才会存在脏读

读到的数据不正确，读到的是在内存中但不在硬盘上并且内存硬盘不一致的数据

* 事务T1读A
* 事务T1修改A在内存中的副本
* 事务T2读A
* 事务T2修改A在内存中的副本
* 事务T1回滚
* 事务T2写回，用到的数据不正确(已经被回滚)

### 不一致分析

读取数据和使用数据之前，数据被其它事务修改

### 解决并发控制问题

* 串行执行
* 调度，保证事务执行的正确性

## 调度

### 定义

读个事务的读写操作按照时间排序的执行序列

* 调度站每个事务的读写操作保持原来顺序
* 不考虑
  * 数据库初始状态
  * 事务的语义

### 定义：可串化调度

* 如何一个调度的结果与某个串行调度执行的结果等价，则称该调度为可串化调度，否则是不可串调度
* 性质：当个事务的执行保证DB从一个一致状态变化到另一个一致状态，N个事务串行调度仍然保证数据库一致性

### 定义：冲突可串化

#### 冲突操作

* 调度中一对连续操作是冲突的，则交换顺序，将会改变一个事务的执行结果
* 两个连续操作不冲突，则可以在调度中交换顺序

#### 冲突等价

通过交换不冲突的连续操作的顺序，可以将S1,S2变成一个顺序，则S1,S2冲突等价

#### 冲突可串性

* 如果一个调度和串行调度冲突等价，就说这个调度具有冲突可串性
* 满足冲突可串行，则为可串化调度

### 优先图

#### 组成

* 节点：事务
* 有向边 $T_i\rightarrow T_j,if$
  * 存在Ti的操作A1和Tj的操作A2
    * A1在A2之前，并且
    * A1和A2是冲突操作

#### 优先图与冲突可串性

如果优先图无环，则一定满足冲突可串性

## 锁与可串行实现

### 任务

* 给定n个并发事务，确定一个可串化调度
* 锁协议——使用锁的规则

### 两阶段锁

释放锁之后不能加锁

### X锁&&S锁

加了S锁不能加X锁，加了X锁不能加其它任何锁

### 多粒度锁——意向锁

针对不同大小的加锁的数据对象加锁，锁粒度越细，并发度越高

## 事务的隔离级别

### 基本概念

1. 脏读：一个事务读到另外一个事务还没有提交的数据，我们称之为脏读。
2. 不可重复读:一个事务先后读取同一条记录，但两次读取的数据不同，我们称之为不可重复读。数据更新
3. 幻象读:一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读，插入数据

### 可串行读

访问数据时，其它事务不能修改数据，也不能插入新元组，不会出现脏读，不可重复读，幻象

### 读取未提交内容

所有事务都可以看到其它未提交事务的执行结果，导致脏读

### 读取提交内容

解决脏读问题，但是一条select读出的相。保证其它事务不会读取到其它未提交事务修改的数据。同记录可能在不同时刻不同，需要在访问的数据上加上S锁，数据一旦读出，就立即释放持有的S锁

### 可重复读

事务开始时读到的已有数据是什么，最后读到的结果中这些数据仍然不变，保证事务内部如果重复访问同一数据，数据不会发生改变，食物在访问数据时，其它事务不能修改正在访问的那部分数据