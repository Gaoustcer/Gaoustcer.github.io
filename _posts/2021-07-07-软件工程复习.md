---
layout:     post
title:      软件工程复习
subtitle:   软件工程复习
date:       2021-07-07
author:     Haihan Gao
header-img: img/post-bg-swift2.jpg
catalog: true
tags:
    - Software Engineer
    - Course review
    - 2021 spring review
---
# 软件工程复习

## 复习提纲

* 错误和缺陷
  * 错误：发布之前
  * 缺陷：软件发布后发现的质量问题
* Pareto原则 80%的漏洞在20%的代码中
* 验证与确认
  * 验证，确保软件正确实现特定功能的任务集合
  * 确认，不同的任务集，可以确保已经构建的软件可以追溯到客户的需求
* 环路复杂度$\in$代码复杂度，函数内部的复杂度
* 软件工程工作量分配
  * 前期活动 40%-50%
  * coding 20%
  * 测试和安装 30%-40%

### 不考

* 第6章
* 第14章
* 第15章
* 第20，21章
* 第26章
* 软件项目管理考察概念

### 考点

第四章

用例图，UML活动图

依赖倒置原则 细节应该依赖于抽象，构建与设计包含四个原则 

$\alpha-\beta$测试区别 $\alpha$是开发者 $\beta$是用户

面向类的测试

## 第一章——软件的本质

* 现在的软件具有产品和产品交付载体的双重作用

### 定义软件

* 指令的集合，通过执行这些指令可以满足预期的特性，功能和性能需求
* 数据结构，使得程序可以合理利用信息
* 软件描述信息，可以以硬拷贝或者虚拟形式存在，用来描述程序的操作和使用

#### 软件的失效

* 硬件失效率是时间的函数，硬件会摸索
* 软件不会磨损，但是存在软件退化

#### 遗留软件

为旧的系统保留的软件

### 软件的变更本质

* `WebApp`，基于Web的系统和应用软件
* 移动APP
* 云计算
* 产品线软件

## 第二章——软件工程

### 定义软件工程学科

* 将系统化的，规范的，可量化的方法应用于软件开发，运行以及维护，将工程化方法应用于软件
* 对前述方法的研究

### 软件过程

* 软件过程是工作产品构建时所执行的一系列活动，动作和人物的集合
* 活动主要实现宽泛的目标
* 动作包含主要工作产品生产过程中的一系列任务
* 任务关注小而明确的目标，能够产生实际产品

#### 过程框架

* 定义了若干个框架活动，一般包含五个活动
* 沟通
* 策划
* 建模
  * 需求分析
  * 设计
* 构建
  * 编码
  * 测试
* 部署

#### 普适性活动

* 软件项目的跟踪和控制
* 风险管理
* 软件质量保证
* 测量
* 技术评审
* 软件配置管理
* 可复用管理
* 工作产品的准备和生产

### 软件工程实践

* 通用的框架活动
* 普适性活动
* 通用原则
  * 存在价值
  * 保持简洁
  * 保持愿景
  * 关注使用者
  * 面向未来
  * 提前计划复用
  * 认真思考

## 软件过程结构

### 通用过程模型

* 过程流——执行顺序和执行时间上如何组织框架中的活动、动作和任务
  * 线性过程流——沟通到部署执行五个框架活动
  * 迭代过程流——执行下一个活动前重复执行之前的一个和多个活动
  * 演化过程流——采取循环的方式执行各个活动，每次循环完善软件版本
  * 并行过程流

### 任务集

定义了为了达到软件工程动作的目标所需要完成的工作

### 过程模式

描述了软件工程工作中遇到的过程相关的问题，明确问题环境并给出了针对该问题的一种或几种可以证明的解决方案

* 模式名称
* 驱动力
* 类型
  * 步骤模式——过程的框架活动相关的问题
  * 任务模式
  * 阶段模式
* 启动条件
* 问题
* 结果
* 相关模式

## 过程模型

### 惯用过程模型

#### 瀑布模型

V模型，质量保证动作同沟通，建模相关动作以及早期构建相关的动作之间的关系

* 沟通——项目启动，需求搜集
* 策划——项目估算，进度计划，项目跟踪
* 建模——分析，设计
* 构建——编码，测试
* 部署——交付，支持，反馈

#### 增量过程模型

逐步迭代，新的增量下逐渐完善，第一个增量是核心产品

#### 演化过程模型

* 原型开发
* 螺旋模型

#### 并发模型

所有的软件工程活动同时存在并处于不同的状态

### 专用过程模型

#### 形式化方法模型

生成计算机软件形式化的数学规格说明

### 统一过程

尝试从传统的软件过程中挖掘最好的特征和性质

## 敏捷开发

### 敏捷和变更成本

* 传统方法 变更成本随着计划的进展成非线性增长
* 敏捷开发 拉平变更曲线

### 敏捷过程基本假设

* 提前预测哪些需求是稳定的以及哪些需求会变更非常困难
* 设计和构建是交错进行的
* 分析、设计、构建和测试并不像我们设想的那么容易预测

## 理解需求

### 需求工程

致力于不断理解需求的大量任务和技术

* 起始
* 获取
* 细化
* 协商
* 规格说明
* 确认

## 需求建模——基于场景的方法

### 需求分析

建立以下一种或多种模型类型

* 场景模型
* 面向类的模型
* 基于行为和模式的模型
* 数据模型
* 面向流的模型

### 域分析

识别，分析和详细说明某个特定应用领域的共同需求

### 需求建模的方法

* 结构化分析 数据作为独立实体加以转换，数据对象建模定义了对象的属性和关系
* 面向对象的分析，关注类的定义和影响用户需求的类之间的协作方式，一般指的是UML图

### 基于场景建模

UML需求建模将从开发用例，活动图1和泳道图的场景开始

* 创建初始用例
* 细化初始用例
* 编写正式用例

### 补充用例的UML模型

#### 开发活动图

* 两端为半圆形的矩形表示一个特定的系统功能
* 箭头表示通过系统的流
* 菱形表示分支
* 实水平线表示并行发生的活动

#### 泳道图

* 允许建模人员表示用例所描述的活动流
* 指出那个参与者或分析类负责由活动矩形描述的的活动
* 职责由纵向分割图中的并行条表示

## 需求建模——基于类的方法

### 识别分析类

什么是分析类

* 外部实体
* 事物
* 偶发事件或事件
* 角色
* 组织单元
* 场地
* 结构

分析类包含的特征

* 保留信息
* 所需服务
* 多个属性
* 公共属性
* 公共操作
* 必要需求

### 描述属性

属性描述了已经选择包含在需求模型中的类

### 定义操作

操作定义了某个对象的行为

### 类—职责—协作者建模

* 职责是和类相关的属性和操作，职责是**类所知道或能做的任何事**
* 协作者是提供完成某个职责所需要的信息的类，协作意味着信息请求或某个动作请求
* 表示类的标准索引卡片的集合，顶部写类名，卡片主体左侧部分列出类的职责，右侧部分列出类的协作者

### 类的分类

* 实体类——问题说明中直接提取出来
* 边界类——创建用户可见的和在使用软件时交互的接口
* 控制类——管理工作单元
  * 实体类的创建或更新
  * 边界类从实体对象获取信息后的实例化
  * 对象集合间的复杂通信
  * 对象间或用户和应用系统间交换数据的确认

### 关联和依赖

* 两个分析类以某种方式相互联系着，这种联系称为关联
* 依赖——两个类之间的依赖关系，由构造类型定义，构造型是一个可扩展机制，用一对尖括号表示`<<stereotype>>`

## 需求建模——行为和模式

### 生成行为模型

行为模型显示了软件如何对外部事物或激励做出相应，要生成模型，分析师必须按照如下步骤进行

1. 评估所有的用例
2. 识别驱动交互顺序的事件
3. 为每个用例生成序列
4. 创建系统状态图
5. 评审行为模型以验证准确性和一致性

## PPT考点总结

### 用例图和用例说明

#### 用例图

参与者，系统外部与系统发生交互的人或事物

* 人指的是参与者与系统发生交互时的角色
* 事物指的是某一个应用程序或特殊进程

用例——动宾结构，相互独立的

用例存在以下关系

* 关联关系，表示参与者与用例之间的关系，用一条直线相连
* 归纳关系，子类指向父类
* 包含关系，箭头从基础用例指向包含用例
* 扩展关系，扩展用例是对基础用例的增强

#### 用例说明

* 用例编号
* 用例名称
* 用例参与者
* 用例描述
* 前置条件
* 触发条件
* 后置条件
* 正常流程
* 异常流程

### 状态机

* 每个状态的系统变量值
* 状态的转移模型

### 任务管理模块活动图

这个感觉就像状态图，注意黑点代表起始，带有圈的黑点代码终止，有多个子节点的父状态需要画一条黑线

### 类图

* 最上方是类的名称
* 中间是类的属性
  * -为私有属性
  * +为共有属性
* 最下方是方法
* 实线箭头从父属性指向子属性
* 虚线箭头从被调用对象指向调用对象

### 等价类划分

#### 如何划分等价类

- 如果输入条件规定了一个取值范围（例如，“数量可以是1到999”），那么就应确定出一个有效等价类（1<数量<999）,以及两个无效等价类（数量<1，数量>999）。
- 如果输入条件规定了取值的个数（例如，“汽车可登记一至六名车主”），那么就应确定出一个有效等价类和两个无效等价类（没有车主，或车主多于六个）。
- 如果输入条件规定了一个输入值的集合，而且有理由认为程序会对每个值进行不同处理（例如，“交通工具的类型必须是公共汽车、卡车、出租车、火车或摩托车”），那么就应为每个输入值确定一个有效等价类和一个无效等价类（例如，“拖车”）。
- 如果存在输入条件规定了“必须是”的情况，例如“标识符的第一个字符必须是字母”，那么就应确定一个有效等价类（首字符是字母）和一个无效等价类（首字符不是字母）。

有效等价类产生有效结果，无效等价类不满足输入条件

#### 利用等价类设计测试用例

* 确定等价类
* 建立等价类表
  * 序号
  * 功能项
  * 有效等价类
  * 编号
  * 无效等价类
  * 无效等价类编号
* 生成测试用例，根据等价类表生成测试用例
  * 编写新的测试用例，尽可能多地覆盖哪些尚未涵盖的有效等价类，直到所有的有效等价类被测试用例所覆盖
  * 编写新的用例，每次覆盖一个尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例所覆盖
  * 覆盖数据包含的表项
    * 测试用例编号
    * 输入
    * 预期输出
    * 用例描述
    * 覆盖等价类

### 环路复杂度计算公式

1. 边数-节点数+2
2. 分支节点+1